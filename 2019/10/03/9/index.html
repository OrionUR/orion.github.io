<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Leetcode,c,algorithm," />





  <link rel="alternate" href="/atom.xml" title="Orion's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="记录我在LeetCode上，做题的心得与代码本篇为LeetCode上算法题目，难度为easy，语言为C语言地址">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法笔记（简单）">
<meta property="og:url" content="http://orionur.github.io/2019/10/03/9/index.html">
<meta property="og:site_name" content="Orion's Blog">
<meta property="og:description" content="记录我在LeetCode上，做题的心得与代码本篇为LeetCode上算法题目，难度为easy，语言为C语言地址">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png">
<meta property="og:image" content="https://leetcode.com/static/images/solutions/Sieve_of_Eratosthenes_animation.gif">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/28/237_example.png">
<meta property="og:updated_time" content="2019-11-27T21:55:06.081Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode算法笔记（简单）">
<meta name="twitter:description" content="记录我在LeetCode上，做题的心得与代码本篇为LeetCode上算法题目，难度为easy，语言为C语言地址">
<meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> LeetCode算法笔记（简单） | Orion's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-77124509-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Orion's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">私人博客，偶尔开开车，挂挂代码，写写影评，聊聊八卦</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            时间轴
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'k5NBNGriRojzYw7vtG3S','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                LeetCode算法笔记（简单）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <time itemprop="dateCreated" datetime="2019-10-03T14:57:00-07:00" content="2019-10-03">
              2019-10-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index">
                    <span itemprop="name">Tech</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/10/03/9/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/10/03/9/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>记录我在LeetCode上，做题的心得与代码<br>本篇为LeetCode上算法题目，难度为easy，语言为C语言<br><a href="https://leetcode.com/problemset/algorithms/?difficulty=Easy" target="_blank" rel="external">地址</a></p>
<a id="more"></a>
<hr>
<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="(1) Two Sum"></a>(1) Two Sum</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.<br>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>用遍历法即可<br>用两个for循环遍历得出答案</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ret = (int *)<span class="built_in">malloc</span>(<span class="number">2</span> * sizeof(int));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (ret[<span class="number">0</span>] = <span class="number">0</span>; ret[<span class="number">0</span>] &lt; numsSize; ++ret[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (ret[<span class="number">1</span>] = ret[<span class="number">0</span>] + <span class="number">1</span>; ret[<span class="number">1</span>] &lt; numsSize; ++ret[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[ret[<span class="number">0</span>]] + nums[ret[<span class="number">1</span>]] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = <span class="number">2</span>;</span><br><span class="line">                returnSize[<span class="number">0</span>] = rs;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="(7) Reverse Integer"></a>(7) Reverse Integer</h2><p>Given a 32-bit signed integer, reverse digits of an integer. </p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31^,  2^31^ − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>换位问题，也就是最低位变最高位，倒数第二位变正数第二位，以此类推<br>方法为求余加上自己本身进位<br>比如例子1，123<br>123对10求余为3，123 / 10 =&gt; 12<br>12对10求余为2，3 <em> 10 + 2 =&gt; 32，12 / 10 =&gt; 1<br>1对10求余为1，32 </em> 10 + 1 =&gt; 321，1 / 10 =&gt;0<br>当源数字为0时，循环结束<br>负数并不影响这个算法的运作</p>
<p>另外，这里要考虑溢出的问题<br>因此用<code>long</code>来定义转换后的值，若是溢出，则返回0（题目要求，备注里）<br>若是未溢出，则最后强制类型转换返回<code>int</code>（因为题目要求返回的类型是int）</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret &gt; INT_MAX || ret &lt; INT_MIN)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (int)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="(9) Palindrome Number"></a>(9) Palindrome Number</h2><p> Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. </p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong><br> Coud you solve it without converting the integer to a string? </p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>跟上边reverse一样，直接把它反过来即可<br>若是负数的话，直接判断为false<br>反过来后，若是和原来的数相等，返回true，否则返回false</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> reverse_x = <span class="number">0</span>, tmp = x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse_x = reverse_x * <span class="number">10</span> + tmp % <span class="number">10</span>;</span><br><span class="line">        tmp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (reverse_x == x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="(13)  Roman to Integer"></a>(13)  Roman to Integer</h2><p> Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>. </p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Symbol</strong></th>
<th style="text-align:center"><strong>Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">L</td>
<td style="text-align:center">50</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">500</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">1000</td>
</tr>
</tbody>
</table>
<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>
<ul>
<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>
<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>
<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>
</ul>
<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>用哈希表（Hash table）来解决这题最为方便<br>由于罗马数字都是字母，而这些字母都是ASCII上<br>于是我们可以建立一个数量为128的数组<br>则数组的位置可以用字母来表示，而它的值，可以为这个字母的值</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> roman_to_int[<span class="number">128</span>] = &#123;</span><br><span class="line">        [<span class="string">'I'</span>] = <span class="number">1</span>, [<span class="string">'V'</span>] = <span class="number">5</span>, [<span class="string">'X'</span>] = <span class="number">10</span>, [<span class="string">'L'</span>] = <span class="number">50</span>,</span><br><span class="line">        [<span class="string">'C'</span>] = <span class="number">100</span>, [<span class="string">'D'</span>] = <span class="number">500</span>, [<span class="string">'M'</span>] = <span class="number">1000</span> </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, pre_c = <span class="number">10000</span>, cur_c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; *s; s++)</span><br><span class="line">    &#123;</span><br><span class="line">        cur_c = roman_to_int[*s];</span><br><span class="line">        ret += cur_c;</span><br><span class="line">        <span class="keyword">if</span> (cur_c &gt; pre_c)</span><br><span class="line">        &#123;</span><br><span class="line">            ret -= (pre_c &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pre_c = cur_c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="(14)  Longest Common Prefix"></a>(14)  Longest Common Prefix</h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>依然是遍历<br>设返回的字符串为第一个input的第一个字符串<br>然后逐字与其他字符串对比，相同则继续，不同则返回<br>需要另外判断的是input为空字符串，那么直接返回<code>“”</code>（题目要求）</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">char</span> ** strs, <span class="keyword">int</span> strsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (strsSize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;strsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((strs[i][j]) &amp;&amp; (ret[j] == strs[i][j]))</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ret[j] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="(20) Valid Parentheses"></a>(20) Valid Parentheses</h2><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题的难点是如何对应，即闭符号（closed bracket）前对应的符号应该是同类型的开符号（Open bracket）<br>我的思路是，建立一个数组，该数组的长度，等同于字符串的长度（保证不会越界）<br>然后遍历字符串，用switch去判断，若是遇到开符号，则往该数组写入一个同类型的闭符号<br>若是遇到闭符号，判断其是否与最后写入的闭符号相同<br>另外还需要定义一个记数变量，来判断是否有闭符号<br>（若是全是开符号，因为没有出现闭符号，循环会直接结束）<br>总共有4种情况是返回false：<br>1.计数器为0（计数器初始化为0）<br>2.遇到闭符号时，判断不一致<br>3.判断结束后，计数器不为0（表示还存在开符号，但没有对应的闭符号）<br>4.input的字符串为空<br>除了以上4种情况之外，都返回true</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sSize = <span class="built_in">strlen</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况4</span></span><br><span class="line">    <span class="keyword">if</span> (sSize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *open_bracket = (char *)<span class="built_in">malloc</span>(sSize);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(*s++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>: open_bracket[count++] = <span class="string">')'</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#123;'</span>: open_bracket[count++] = <span class="string">'&#125;'</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: open_bracket[count++] = <span class="string">']'</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>: </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#125;'</span>: </span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>:              </span><br><span class="line">                <span class="comment">// 情况1</span></span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    return <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况2</span></span><br><span class="line">                <span class="keyword">if</span> (open_bracket[count - <span class="number">1</span>] != *(s - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    return <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况3</span></span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(open_bracket);</span><br><span class="line"></span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="(21) Merge Two Sorted Lists"></a>(21) Merge Two Sorted Lists</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>用递归做最为简便<br>首先判断l1和l2是否为空，如果为空，则直接返回另一个<br>如l1为空，返回l2……反之，返回l1<br>若是两个都不为空，则比较val值大小，较小的next进入递归，进行下一次判断比较</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> ListNode* <span class="title">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>)</span><br><span class="line">        return l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>)</span><br><span class="line">        return l1;</span><br><span class="line">    <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        return l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="(26) Remove Duplicates from Sorted Array"></a>(26) Remove Duplicates from Sorted Array</h2><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment">// using the length returned by your function, it prints the first len elements.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>老规矩，遍历即可<br>若数组长度小于2，即为0或1，则直接返回该长度即可<br>若是大于等于2，则开始遍历<br>若相同，继续比较下一个……若不同，则长度+1</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[++j] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ++j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="(27) Remove Element"></a>(27) Remove Element</h2><p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external">in-place</a></strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment">// using the length returned by your function, it prints the first len elements.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>和上一题大同小异，同样也是遍历<br>若是数组某一元素的值与给出的val不相等，就把该元素的值覆盖该数组第一个元素</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="(28) Implement strStr()"></a>(28) Implement strStr()</h2><p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="external">strStr()</a>.</p>
<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<p><strong>Clarification:</strong></p>
<p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="external">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String" target="_blank" rel="external">indexOf()</a>).</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>用函数strncmp去比较即可，需要注意的是越界问题<br>同时若needle为空，则返回0（题目备注）</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">char</span> * haystack, <span class="keyword">char</span> * needle)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> haystack_len = <span class="built_in">strlen</span>(haystack), needle_len = <span class="built_in">strlen</span>(needle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!needle_len)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ret + needle_len &lt;= haystack_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(haystack++, needle, needle_len))</span><br><span class="line">        &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        ret++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="(35) Search Insert Position"></a>(35) Search Insert Position</h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>太简单了，遍历</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="(38) Count and Say"></a>(38) Count and Say</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure>
<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p>
<p>Given an integer <em>n</em> where 1 ≤ <em>n</em> ≤ 30, generate the <em>n</em>th term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;1211&quot;</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>由于没法判断长度，所以我<code>malloc</code>申请的空间大小为10000（应该用calloc的，偷懒了）<br>由于每一行都需要根据上一行来决定，所以没法偷懒，用2个for循环来实现<br>第一个for循环为生成的行数，即第1行，第5行，第10行<br>第二个for循环为生成每个行数的字符串值<br>算法为，若数字相同，则计数器加1……否则，先输出计数器，再输出数字到临时字符串上<br>用<code>+ &#39;0&#39;</code>来实现int to char转换（要求输出字符串）</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = (char *)<span class="built_in">malloc</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">char</span> *tmp = (char *)<span class="built_in">malloc</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    <span class="keyword">int</span> ret_len;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, num = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret[<span class="number">0</span>] = <span class="string">'1'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret_len = <span class="built_in">strlen</span>(ret);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;ret_len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == ret[j] - <span class="string">'0'</span>)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (count != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[k++] = count + <span class="string">'0'</span>;</span><br><span class="line">                    tmp[k++] = num + <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num = ret[j] - <span class="string">'0'</span>;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp[k++] = count + <span class="string">'0'</span>;</span><br><span class="line">        tmp[k++] = num + <span class="string">'0'</span>;</span><br><span class="line">        tmp[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(ret, tmp, <span class="built_in">strlen</span>(tmp)+<span class="number">1</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="(53) Maximum Subarray"></a>(53) Maximum Subarray</h2><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>依然是用遍历法解决问题<br>需要设定两个变量，一个是最大值，一个是临时最大值<br>若临时最大值 &gt; 最大值，那么就把临时最大值赋予给最大值<br>临时最大值为每个数组元素相加，若临时最大值为负数，则初始化为0</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum_max = INT_MIN, max_val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        max_val += nums[i];</span><br><span class="line">        sum_max = sum_max &gt; max_val ? sum_max : max_val;</span><br><span class="line">        <span class="keyword">if</span> (max_val &lt; <span class="number">0</span>)</span><br><span class="line">            max_val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return sum_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="(58) Length of Last Word"></a>(58) Length of Last Word</h2><p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p><strong>Note:</strong> A word is defined as a character sequence consists of non-space characters only.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Hello World&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>得到字符串的长度，然后反过来数即可<br>需要注意判断空格，这里有2种情况<br>1.空格前（反过来看）已经有字（word）了，那么直接终止循环输出结果<br>2.空格前没有字，那么继续循环，直到计数器开始记数，或者字符串遍历完</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=s_len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">' '</span>)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">' '</span> &amp;&amp; count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="(66) Plus One"></a>(66) Plus One</h2><p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题很阴险……给出的是数组，因此不能直接+1，同时还要考虑越界问题<br>因此malloc的时候，要多一个<code>sizeof(int)</code>空间<br>先判断+1后是否有进位，若有进位，则继续往高位+1，直到没有进位发生为之<br>若循环结束后最高位依然有存在，则表示会越界，也就说<br>原本长度是n的input，+1后长度变成n+1<br>因此直接把要返回的字符串首位置为1即可（因为只会进位1）<br>然后把修改后的字符串复制到新的字符串后<br>（若是进位不存在，直接复制，不用把首位置为1）</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span>* digits, <span class="keyword">int</span> digitsSize, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ret = (int *)<span class="built_in">malloc</span>(digitsSize * sizeof(int) + sizeof(int));</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>, i = digitsSize - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    digits[i] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] += carry;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] -= <span class="number">10</span>;</span><br><span class="line">            carry++;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">if</span> (!carry)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span> (i != <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (carry)</span><br><span class="line">    &#123;</span><br><span class="line">        ret[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = digitsSize + j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;digitsSize; i++, j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret[j] = digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="(67) Add Binary"></a>(67) Add Binary</h2><p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>同样的，传进来的参数是字符串，需要把字符串换变为整数进行计算，再转换为字符串输出<br>还是需要思考进位问题……若是产生进位，则值-2，进位置1<br>同时还要考虑两个字符串长度问题，若其中一方字符串长度为0，则只计算另一方</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">addBinary</span><span class="params">(<span class="keyword">char</span> * a, <span class="keyword">char</span> * b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a_len = <span class="built_in">strlen</span>(a), b_len = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">int</span> j, i = a_len &gt; b_len ? a_len : b_len;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ret = (char *)<span class="built_in">malloc</span>(i + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">char</span> *tmp = (char *)<span class="built_in">malloc</span>(i + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(ret, <span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a_len || b_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a_len &amp;&amp; b_len)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = (a[a_len<span class="number">-1</span>] + b[b_len<span class="number">-1</span>] + carry) - <span class="number">2</span> * <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!a_len)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = (b[b_len<span class="number">-1</span>] + carry) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = (a[a_len<span class="number">-1</span>] + carry) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp[i] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] -= <span class="number">2</span>;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        a_len = a_len &gt; <span class="number">0</span> ? a_len - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        b_len = b_len &gt; <span class="number">0</span> ? b_len - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (carry)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; i&gt;=<span class="number">0</span>; i--,j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret[j] = tmp[i] + <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret[j] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="(69) Sqrt(x)"></a>(69) Sqrt(x)</h2><p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of <em>x</em>, where <em>x</em> is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>用二分法来解此题<br>设最小值为1，最大值为input的值<br>考虑到越界问题，采用（最大值 - 最小值）/2 + 最小值的方法来二分<br>将得到的值平方后与input相比较，若是相等直接输出结果（可以直接开方，不会产生小数）<br>若是小于input，则最小值为得到的值+1<br>若是大于input，则最大值为得到的值-1<br>一直循环到，最小值小于等于最大值为止（二分结束）<br>若是结束循环，则返回最大值（会产生小数）</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>, e = x;</span><br><span class="line">    <span class="keyword">long</span> m, mm;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (s &lt;= e)</span><br><span class="line">    &#123;</span><br><span class="line">        m = s + (e - s) / <span class="number">2</span>;</span><br><span class="line">        mm = m * m;</span><br><span class="line">        <span class="keyword">if</span> (mm == x)</span><br><span class="line">            return m;</span><br><span class="line">        <span class="keyword">if</span> (mm &lt; x)</span><br><span class="line">            s = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            e = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="(70) Climbing Stairs"></a>(70) Climbing Stairs</h2><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>找规律题<br>规律为，新一阶等于上一阶 + 上上一阶<br>因此若input &lt;= 2，则返回本身<br>然后用循环得到新一阶需要的步数，直到执行input那么多次</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        return n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="(83) Remove Duplicates from Sorted List"></a>(83) Remove Duplicates from Sorted List</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>简单的链表题目<br>定义两个变量，一个为现在位置，一个为之前位置<br>若是之前位置的值 = 现在位置的值，则继续遍历，直到不相等为止<br>若是不相等，则之前位置链接到现在位置，之前位置变为现在的位置，现在位置变为下一个位置<br>循环直到现在位置为null为止<br>需要注意的是，结束循环后还要再判断一下之前位置与现在位置是否相同<br>若是不同，则之前位置需要链接到现在位置（也就是null）</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> ListNode* <span class="title">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        return <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> ListNode *cur, *pre;</span><br><span class="line">    cur = pre = head;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == pre-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre != cur)</span><br><span class="line">        pre-&gt;next = cur;</span><br><span class="line"></span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="(88) Merge Sorted Array"></a>(88) Merge Sorted Array</h2><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>由于题目已经设定好不会越界，因此malloc申请的空间为<code>sizeof(int) * (m + n)</code>即可<br>用遍历法，比较两个数组的各元素大小，小的值放在临时数组里（也就是我malloc申请空间的那个数组）<br>当其中一方遍历完后，另一方直接写入，不需要进行比较<br>最后将临时数组复制到nums1数组即可<br>（我的做法会导致空间复杂度增加，但C语言不像C++那样，有函数可以直接插入到数组里）<br>（如果不用这个方法，会导致时间复杂度增加，程序也会变得更加复杂，难以阅读）</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> m, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *tmp = (int *)<span class="built_in">malloc</span>(sizeof(int) * (m + n));</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m + n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == m)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = nums2[b];</span><br><span class="line">            b++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b == n)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = nums1[a];</span><br><span class="line">            a++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1[a] &gt; nums2[b])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = nums2[b];</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = nums1[a];</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m + n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums1[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="(100) Same Tree"></a>(100) Same Tree</h2><p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这里要考虑3个情况<br>1）两方都是空<br>2）其中一方为空<br>3）是否相同<br>其中情况一单独判断，其余两种可以结合判断</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p &amp;&amp; !q)</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        return (p &amp;&amp; q) &amp;&amp; (p-&gt;val == q-&gt;val)</span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="(101) Symmetric Tree"></a>(101) Symmetric Tree</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>Bonus points if you could solve it both recursively and iteratively.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>由于镜像对比是，最外和最外相比较里面和里面相比较<br>那么写成算法，就是left-&gt;left和right-&gt;right相比较<br>left-&gt;right和right-&gt;left相比较<br>其他的和上一题基本相同<br>迭代的方法太麻烦了，这里我就省略了</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p &amp;&amp; !q)</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        return (p &amp;&amp; q) &amp;&amp; (p-&gt;val == q-&gt;val)</span><br><span class="line">        &amp;&amp; isMirror(p-&gt;left, q-&gt;right) &amp;&amp; isMirror(p-&gt;right, q-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span>&#123;</span><br><span class="line">    return isMirror(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="(104) Maximum Depth of Binary Tree"></a>(104) Maximum Depth of Binary Tree</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its depth = 3.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这里需要对递归的结果作出一个判断<br>比如从root开始，root-&gt;left和root-&gt;right，取depth更多的一边作为结果<br>由于root也算是一层，所以输出的结果要加上root这一层</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dep = <span class="number">0</span>, left, right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        return dep;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dep++;</span><br><span class="line">    </span><br><span class="line">    left = maxDepth(root-&gt;left);</span><br><span class="line">    right = maxDepth(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    return dep + (left &gt; right ? left : right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="(107) Binary Tree Level Order Traversal II"></a>(107) Binary Tree Level Order Traversal II</h2><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题有2个难点<br>第一个是内存分配，需要用上一题的代码，直接得出二叉树的深度，然后直接申请内存<br>我试过一边遍历一边申请内存，这样速度太慢，空间复杂度也高<br>第二个是什么时候把值写入数组中，由于要求倒序写入，这里应该采用后序遍历<br>这题我还是采用了递归来写，迭代实在太麻烦了，懒得搞</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Return an array of arrays of size *returnSize.</span><br><span class="line"> * The sizes of the arrays are returned as *returnColumnSizes array.</span><br><span class="line"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dep = <span class="number">0</span>, left, right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        return dep;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dep++;</span><br><span class="line">    </span><br><span class="line">    left = maxDepth(root-&gt;left);</span><br><span class="line">    right = maxDepth(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    return dep + (left &gt; right ? left : right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="keyword">int</span> depth, <span class="keyword">int</span> **arr, <span class="keyword">int</span> *reSize, <span class="keyword">int</span> **reCoSizes)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) return;</span><br><span class="line">    </span><br><span class="line">    postOrder(root-&gt;left, depth + <span class="number">1</span>, arr, reSize, reCoSizes);</span><br><span class="line">    postOrder(root-&gt;right, depth + <span class="number">1</span>, arr, reSize, reCoSizes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> idx = *reSize - depth;</span><br><span class="line">    </span><br><span class="line">    arr[idx] = (int *)<span class="built_in">realloc</span>(arr[idx], ((*reCoSizes)[idx] + <span class="number">1</span>) * sizeof(int));</span><br><span class="line">    arr[idx][(*reCoSizes)[idx]] = root-&gt;val;</span><br><span class="line">    ++(*reCoSizes)[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">levelOrderBottom</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> **arr, depth;</span><br><span class="line">    </span><br><span class="line">    depth = maxDepth(root);</span><br><span class="line">    arr = (int **)<span class="built_in">calloc</span>(depth, sizeof(int *));</span><br><span class="line">    *returnColumnSizes = (int *)<span class="built_in">calloc</span>(depth, sizeof(int));</span><br><span class="line">    *returnSize = depth;</span><br><span class="line">    </span><br><span class="line">    postOrder(root, <span class="number">1</span>, arr, returnSize, returnColumnSizes);</span><br><span class="line">    </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="(108) Convert Sorted Array to Binary Search Tree"></a>(108) Convert Sorted Array to Binary Search Tree</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>用二分法做这题比较好<br>需要注意的是，左边不会存在越界的问题，所以直接二分就好<br>而右边会有越界的问题，所以需要判断是否越界</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!numsSize) return <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> TreeNode *head = (struct TreeNode*)<span class="built_in">malloc</span>(sizeof(struct TreeNode));</span><br><span class="line">    <span class="keyword">int</span> n = numsSize / <span class="number">2</span>;</span><br><span class="line">    head-&gt;val = nums[n];</span><br><span class="line">    head-&gt;left = sortedArrayToBST(nums, n);</span><br><span class="line">    <span class="keyword">if</span> (numsSize - n &gt; <span class="number">1</span>)</span><br><span class="line">        head-&gt;right = sortedArrayToBST(nums + n + <span class="number">1</span>, numsSize - n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        head-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="(110) Balanced Binary Tree"></a>(110) Balanced Binary Tree</h2><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>Return true.</p>
<p><strong>Example 2:</strong></p>
<p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<p>Return false.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这里要求的是every node，每个节点都要当新的节点来判断<br>于是要分两步，首先要得出最大深度，用上边的代码即可<br>第二步是，比较左右最大深度，若是超过1，返回false<br>然后递归比较每个节点</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right, count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        count++;</span><br><span class="line">    </span><br><span class="line">    left = getDepTree(root-&gt;left);</span><br><span class="line">    right = getDepTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    return count + (left &gt; right ? left : right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = getDepTree(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = getDepTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="(111) Minimum Depth of Binary Tree"></a>(111) Minimum Depth of Binary Tree</h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its minimum depth = 2.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题很阴险的是，从root开始到最近的leaf<br>也就是说，如果二叉树是[1, 2]的话，结果应该是2，而不是1<br>因此需要额外加一个判断语句</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    left = minDepth(root-&gt;left);</span><br><span class="line">    right = minDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>)</span><br><span class="line">        return count + left + right;</span><br><span class="line"></span><br><span class="line">    return count + (left &lt; right ? left : right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="(112) Path Sum"></a>(112) Path Sum</h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>
<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>同样要求的是从root-to-leaf，也就是说，那么等于sum了，只要这个node还有child，都不算对<br>于是不单单需要判断是否等于sum，还需要判断是否leaf</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (((sum - root-&gt;val) == <span class="number">0</span>) &amp;&amp; (!root-&gt;left) &amp;&amp; (!root-&gt;right))</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    return (hasPathSum(root-&gt;left, (sum - root-&gt;val)) || hasPathSum(root-&gt;right, (sum - root-&gt;val)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="(118) Pascal’s Triangle"></a>(118) Pascal’s Triangle</h2><p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>图里都把规律给出来了，直接写就是了</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Return an array of arrays of size *returnSize.</span><br><span class="line"> * The sizes of the arrays are returned as *returnColumnSizes array.</span><br><span class="line"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> **Pascal, i, j;</span><br><span class="line">    </span><br><span class="line">    *returnSize = numRows;</span><br><span class="line">    Pascal = (int **)<span class="built_in">malloc</span>(sizeof(int *) * numRows);</span><br><span class="line">    *returnColumnSizes = (int *)<span class="built_in">malloc</span>(sizeof(int) * numRows);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numRows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pascal[i] = (int *)<span class="built_in">malloc</span>(sizeof(int) * (i+<span class="number">1</span>));</span><br><span class="line">        Pascal[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        Pascal[i][i] = <span class="number">1</span>;</span><br><span class="line">        (*returnColumnSizes)[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>; i &gt;=<span class="number">2</span> &amp;&amp; j&lt;i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Pascal[i][j] = Pascal[i<span class="number">-1</span>][j<span class="number">-1</span>] + Pascal[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return Pascal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="(119) Pascal’s Triangle II"></a>(119) Pascal’s Triangle II</h2><p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这里若是要用空间复杂度为O(k)来做的话，其实也很简单<br>就是把上题j - 1和j，用另外两个变量储存起来就可以了</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *pascal = (int *)<span class="built_in">malloc</span>(sizeof(int) * (rowIndex+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> i, j, tmp1, tmp2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rowIndex+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pascal[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        pascal[i] = <span class="number">1</span>;</span><br><span class="line">        tmp2 = pascal[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp1 = tmp2;</span><br><span class="line">            tmp2 = pascal[j];</span><br><span class="line">            pascal[j] = tmp1 + tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = i;</span><br><span class="line">    </span><br><span class="line">    return pascal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="(121) Best Time to Buy and Sell Stock"></a>(121) Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">             Not 7-1 = 6, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>规律是，如果day n是小于day n+1，那么利润profit是肯定存在的，也就是 &gt; 0<br>然后若是day n+1 &gt; day n+2，那么最大利润还是day n和day n+1<br>若是day n+1 &lt; day n+2，那么最大利润就是day n和day n+2<br>那么就可以得出规律<br>首先，找到最大利润，也就是，每个节点与之前最小的那个节点相减<br>然后再判断这个节点是否比之前的节点还要小，若是，则替换成最小节点<br>这样，利润取最大值，节点取最小值，利用循环，就可以求出结果</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pricesSize) return <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min_p = prices[<span class="number">0</span>], max_p = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;pricesSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        max_p = max_p &gt; (prices[i] - min_p) ? max_p : (prices[i] - min_p);</span><br><span class="line">        min_p = min_p &lt; prices[i] ? min_p : prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return max_p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="(122) Best Time to Buy and Sell Stock II"></a>(122) Best Time to Buy and Sell Stock II</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题比上一题要简单，就是判断与前一个的值相减是否大于0，是就累加，不是就忽略</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pricesSize) return <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_p = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;pricesSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] - prices[i<span class="number">-1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            max_p += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return max_p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="(125) Valid Palindrome"></a>(125) Valid Palindrome</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题不难，就是有点麻烦<br>不是字母或者数字的需要跳过，然后不区分大小写<br>于是要额外写两个函数，一个是转换大小写，另一个是判断是不是字母或者数字</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strlwr</span><span class="params">(<span class="keyword">char</span> *s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sSize = <span class="built_in">strlen</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">'A'</span> &amp;&amp; s[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">            s[i] += <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAlphanumeric</span><span class="params">(<span class="keyword">char</span> s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 由于我是先转换后判断，所以就不写判断大写的情况了</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="string">'a'</span> &amp;&amp; s &lt;= <span class="string">'z'</span>)</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= <span class="string">'0'</span> &amp;&amp; s &lt;= <span class="string">'9'</span>)</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sSize = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = sSize - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!sSize) return <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    s = strlwr(s);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sSize &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlphanumeric(s[i])) </span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isAlphanumeric(s[j]))</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[j])</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == j)</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="(136) Single Number"></a>(136) Single Number</h2><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题是考你懂不懂用异或运算符</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">        a = a ^ nums[i];</span><br><span class="line">    </span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="(141) Linked List Cycle"></a>(141) Linked List Cycle</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1], pos = -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p><strong>Follow up:</strong></p>
<p>Can you solve it using <em>O(1)</em> (i.e. constant) memory?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>首先分析题目<br>返回false很好判断，遇到null就可以返回false了，那么难点就是如何判断返回true<br>如果一直next，直到null就返回false，那么会导致死循环，若是形成circle的话，所以不可行<br>那么定义两个结构体，一个一直next，另一个原地不动，相遇了就是circle<br>这里也有一个问题，就是不知道哪个点是circle点<br>如例一，circle点是1，若是原地不动的在0点，那么就会永不相遇，导致死循环<br>综上所述，只要两个一起跑，一个跑快点，一个跑慢点，那么总会相遇的（如果形成circle的话）</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *p1, *p2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) return <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) return <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    p1 = head-&gt;next;</span><br><span class="line">    p2 = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">NULL</span> &amp;&amp; p2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val == p2-&gt;val) return <span class="literal">true</span>;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">NULL</span>) return <span class="literal">false</span>;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="(155) Min Stack"></a>(155) Min Stack</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题有个比较严重的问题，就是没给出栈的大小<br>也就是说，我们要自己设立一个栈的大小，而这个值，是根据leetcode它测试案例来决定的<br>我尝试过1000，不行，太小了<br>于是就粗暴的多加一个0，变成10000，懒得去测试边界了<br>另外一个问题是，getMin()这个函数<br>要是写一个循环，每次都找最小值，那样时间复杂度太高了<br>于是就采用另一种方法，在push的时候顺便得出当前最小值，这样速度就快很多了<br>简单来说，就是用空间换时间</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125; MSEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    MSEntry <span class="built_in">array</span>[MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; MinStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MinStack* <span class="title">minStackCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MinStack *<span class="built_in">stack</span> = (MinStack *)<span class="built_in">malloc</span>(sizeof(MinStack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPush</span><span class="params">(MinStack* <span class="built_in">stack</span>, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;size)</span><br><span class="line">        <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;size].min = <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;size - <span class="number">1</span>].min &lt; x</span><br><span class="line">                                    ? <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;size - <span class="number">1</span>].min : x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;size].min = x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;size++].val = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPop</span><span class="params">(MinStack* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackTop</span><span class="params">(MinStack* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    return <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;size - <span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackGetMin</span><span class="params">(MinStack* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    return <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;size - <span class="number">1</span>].min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackFree</span><span class="params">(MinStack* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your MinStack struct will be instantiated and called as such:</span><br><span class="line"> * MinStack* obj = minStackCreate();</span><br><span class="line"> * minStackPush(obj, x);</span><br><span class="line"> </span><br><span class="line"> * minStackPop(obj);</span><br><span class="line"> </span><br><span class="line"> * int param_3 = minStackTop(obj);</span><br><span class="line"> </span><br><span class="line"> * int param_4 = minStackGetMin(obj);</span><br><span class="line"> </span><br><span class="line"> * minStackFree(obj);</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="(160) Intersection of Two Linked Lists"></a>(160) Intersection of Two Linked Lists</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" target="_blank" rel="external"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt="img"></a></p>
<p>begin to intersect at node c1. </p>
<p><strong>Example 1:</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank" rel="external"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">Output: Reference of the node with value = 8</span><br><span class="line">Input Explanation: The intersected node&apos;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank" rel="external"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">Output: Reference of the node with value = 2</span><br><span class="line">Input Explanation: The intersected node&apos;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank" rel="external"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">Output: null</span><br><span class="line">Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</span><br><span class="line">Explanation: The two lists do not intersect, so return null.</span><br></pre></td></tr></table></figure>
<p><strong>Notes:</strong></p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>原本我做这题的思路是：<br>先求出两个linked list的长度，然后若是他们会相交，那么必定是从他们的相差之后<br>也就是说，若是A list长度为8，B list长度为4，那么若是他们相交<br>那么A和B最后相交的长度是相同了，同为3或更少<br>所以A从A[5]开始，B从B[1]开始<br>为什么从3开始，而不是4呢？<br>因为例题里也说明了<code>note that this must not be 0 if the two lists intersect</code><br>所以从这样的话，需要3个循环<br>第一个循环求出长度，第二个循环把各自的list移动到可能相交的点，第三个循环找出相交的点</p>
<p>这个思路不是不好，只是有更好的：<br>因为两个list若是相交，那么最后的长度是一样的<br>那么，我照常移动两个list，若是A到头了（等于NULL），让A=B，继续移动<br>同理B也是如此<br>那么最后，肯定是会同时移动到相交的点<br>这样，我只要一个循环就可以求出答案，时间复杂度和空间复杂度都比上边的思路要好</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> ListNode *<span class="title">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *pA = headA, *pB = headB;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (headA &amp;&amp; headB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == headB) return headA;</span><br><span class="line">        </span><br><span class="line">        headA = headA-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            headA = pB;</span><br><span class="line">            pB = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        headB = headB-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (headB == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            headB = pA;</span><br><span class="line">            pA = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="(167) Two Sum II - Input array is sorted"></a>(167) Two Sum II - Input array is sorted</h2><p>Given an array of integers that is already <strong><em>sorted in ascending order\</em></strong>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Your returned answers (both index1 and index2) are not zero-based.</li>
<li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>先审题，题目有3个条件<br>1）排序好了的，而且是升序排序<br>2）结果不为空<br>3）只有唯一解，且同一元素不会出现两次<br>根据条件，我们可以得出几个结论<br>1）算法根据这个得出的<br>2）传进来不会是空数据，也就是说，不用考虑数据为空的情况<br>3）返回的size恒定为2，i ≠ j<br>让i为首元素，j为末元素<br>当两个值相加大于target，那么j–；若是小于target，那么i++<br>这样的话，不管target是正还是负，都能正确得出结果</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> numbersSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *res = (int *)<span class="built_in">malloc</span>(sizeof(int) * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    </span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = numbersSize - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (numbers[i] + numbers[j] != target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] + numbers[j] &gt; target)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res[<span class="number">0</span>] = ++i;</span><br><span class="line">    res[<span class="number">1</span>] = ++j;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="168-Excel-Sheet-Column-Title"><a href="#168-Excel-Sheet-Column-Title" class="headerlink" title="(168) Excel Sheet Column Title"></a>(168) Excel Sheet Column Title</h2><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;A&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 28</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 701</span><br><span class="line">Output: &quot;ZY&quot;</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题的难点是，如何知道输出的字符串的长度<br>单纯的➗26并不可行<br>正确的规律是，n % 26的结果若是0，则标记<br>若有标记，则n = n / 26 - 1；若无标记，则n = n / 26；<br>这样就可以正确算出长度<br>剩下的就简单了，余数为0则为Z，余数不为零则是余数 + 64</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c_size = <span class="number">0</span>, col = n, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (col)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (col % <span class="number">26</span> == <span class="number">0</span>)</span><br><span class="line">            flag++;</span><br><span class="line"></span><br><span class="line">        col /= <span class="number">26</span>;</span><br><span class="line">        col -= flag;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        c_size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *c_title = (char *)<span class="built_in">calloc</span>(c_size + <span class="number">1</span>, sizeof(char));</span><br><span class="line">    c_size--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        col = n % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span> (!col)</span><br><span class="line">        &#123;</span><br><span class="line">            c_title[c_size--] = <span class="string">'Z'</span>;</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            c_title[c_size--] = (char)(col + <span class="number">64</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        n /= <span class="number">26</span>;</span><br><span class="line">        n -= flag;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return c_title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="(169) Majority Element"></a>(169) Majority Element</h2><p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题有好几个解题思路，原本我只想到穷举法，哈希表法，排序法<br>最优那个我也没想出来，是看solution才发现，真的妙啊<br>最优解的思路是这样的：<br>答案作为majority，而且题目也标粗了<code>more than</code><br>所以答案的值，是超过其他值的数量的<br>因此，可以用计数加减法来找出答案</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, candidate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!count) candidate = nums[i];</span><br><span class="line">        count += (nums[i] == candidate) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="(171) Excel Sheet Column Number"></a>(171) Excel Sheet Column Number</h2><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这个比之前的数字转字母简单多了，不用考虑长度</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">        num = num * <span class="number">26</span> + (int)(*(s++) - <span class="string">'A'</span> + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="172-Factorial-Trailing-Zeroes"><a href="#172-Factorial-Trailing-Zeroes" class="headerlink" title="(172) Factorial Trailing Zeroes"></a>(172) Factorial Trailing Zeroes</h2><p>Given an integer <em>n</em>, return the number of trailing zeroes in <em>n</em>!.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 3! = 6, no trailing zero.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 5! = 120, one trailing zero.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Your solution should be in logarithmic time complexity.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>找规律的一道题，没什么好说的</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count += n / <span class="number">5</span>;</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="(189) Rotate Array"></a>(189) Rotate Array</h2><p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [-1,-100,3,99] and k = 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation: </span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>
<li>Could you do it in-place with O(1) extra space?</li>
</ul>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>1）首先想到的就是插入法，直接把队列末尾的值插入到队首，重复k次，如代码1<br>这种方法是时间复杂度是最高的，为O(n <em> k)，空间复杂度是O(1)<br>2）然后就是建立一个临时数组，直接把要排列的顺序写入到临时数组中，最后再拷贝回来，如代码2<br>这种方法的时间复杂度是O(n </em> 2)，空间复杂度是最高的，为O(n)<br>剩下的没想出来，看了solution之后，发现还有2种方法<br>3）方法3是圆形循环替换法，比方说<br>[1, 2, 3, 4, 5, 6, 7]，k = 3，nums[0]保存在tmp变量中<br>第一次替换后为[1, 2, 3, 1, 5, 6, 7]，就是把nums[0]移动到nums[3]，nums[3]保存在tmp变量中<br>第二次替换后为[1, 2, 3, 1, 5, 6, 4]，就是把nums[3]移动到nums[6]，nums[6]保存在tmp变量中<br>第三次替换后为[1, 2, 7, 1, 5, 6, 4]，就是把nums[6]移动到nums[2]，nums[2]保存在tmp变量中<br>于是就形成圆形循环了，如此重复，直到循环numsSize次，就可以得出结论<br>这里有个问题，若是数组长度 % k = 0，会形成死循环，比如<br>[1, 2, 3, 4, 5, 6]，k = 2，nums[0]保存在tmp变量中<br>第一次替换后为[1, 2, 1, 4, 5, 6]，就是把nums[0]移动到nums[2]，nums[2]保存在tmp变量中<br>第二次替换后为[1, 2, 1, 4, 3, 6]，就是把nums[2]移动到nums[4]，nums[4]保存在tmp变量中<br>第三次替换后为[5, 2, 1, 4, 3, 6]，就是把nums[4]移动到nums[0]，nums[0]保存在tmp变量中<br>这样就形成了死循环，永远只在偶数元素上进行替换，不会轮到基数元素上<br>因此要对这种情况作出判断处理，具体结果如代码3<br>这种方法时间复杂度是O(n)，空间复杂度是O(1)<br>4）最后一种方法就是倒序法，如例题[1, 2, 3, 4, 5, 6, 7]，k = 3<br>直接把数组倒过来，变成[7, 6, 5, 4, 3, 2, 1]<br>然后再把前k个元素倒过来，变成[5, 6, 7, 4, 3, 2, 1]<br>最后再把后边的元素倒过来，变成[5, 6, 7, 1, 2, 3, 4]，答案就出来了<br>这种方法时间复杂度是O(n)，空间复杂度是O(1)<br>因此后两种方法是最优解</p>
</blockquote>
<p><strong>代码1：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endToTop</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[numsSize<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=numsSize<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[<span class="number">0</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        endToTop(nums, numsSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码2：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp[numsSize], i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp[(i + k) % numsSize] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码3：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp, next, start;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 避免溢出</span></span><br><span class="line">    k = k % numsSize;</span><br><span class="line">    next = start = <span class="number">0</span>;</span><br><span class="line">    tmp = nums[start];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        next = (next + k) % numsSize;</span><br><span class="line">        tmp = nums[next] ^ tmp;</span><br><span class="line">        nums[next] = nums[next] ^ tmp;</span><br><span class="line">        tmp = nums[next] ^ tmp;</span><br><span class="line">        <span class="comment">// 判断是否形成了死循环</span></span><br><span class="line">        <span class="keyword">if</span> (next == start &amp;&amp; start &lt; numsSize<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            start++;</span><br><span class="line">            next = (start) % numsSize;</span><br><span class="line">            tmp = nums[start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码4：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; ((end - start) / <span class="number">2</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = nums[i + start];</span><br><span class="line">        nums[i + start] = nums[end-i<span class="number">-1</span>];</span><br><span class="line">        nums[end-i<span class="number">-1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 避免溢出</span></span><br><span class="line">    k = k % numsSize;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, k);</span><br><span class="line">    reverse(nums, k, numsSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="(190) Reverse Bits"></a>(190) Reverse Bits</h2><p>Reverse bits of a given 32 bits unsigned integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 00000010100101000001111010011100</span><br><span class="line">Output: 00111001011110000010100101000000</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 11111111111111111111111111111101</span><br><span class="line">Output: 10111111111111111111111111111111</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank" rel="external">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>
</ul>
<p><strong>Follow up</strong>:</p>
<p>If this function is called many times, how would you optimize it?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>直接用位操作就可以很快地解决这道题</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++, n &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        ret = (ret &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="(191) Number of 1 Bits"></a>(191) Number of 1 Bits</h2><p>Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="external">Hamming weight</a>).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 00000000000000000000000000001011</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The input binary string 00000000000000000000000000001011 has a total of three &apos;1&apos; bits.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 00000000000000000000000010000000</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The input binary string 00000000000000000000000010000000 has a total of one &apos;1&apos; bit.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 11111111111111111111111111111101</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &apos;1&apos; bits.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank" rel="external">2’s complement notation</a>. Therefore, in <strong>Example 3</strong> above the input represents the signed integer <code>-3</code>.</li>
</ul>
<p><strong>Follow up</strong>:</p>
<p>If this function is called many times, how would you optimize it?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>同样是移位操作和判断即可</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(uint32_t n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="(198) House Robber"></a>(198) House Robber</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">             Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).</span><br><span class="line">             Total amount you can rob = 2 + 9 + 1 = 12.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>由于题目限制，数组里不会出现负数<br>因此只要加上去，数值肯定是越来越大，只是限制了不能连续加，于是问题就是怎么表示这个限制<br>算法是，设置三个变量，一个为偷，一个为不偷，一个为临时<br>若是不偷+next &gt; 偷，那么就把偷 = 不偷+next，然后不偷 = 偷（原来的值）<br>这样就可以避免触发连续偷这个限制了</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> noRob = <span class="number">0</span>, rob = <span class="number">0</span>, tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = rob;</span><br><span class="line">        rob = (noRob + nums[i] &gt; rob) ? (noRob + nums[i]) : rob;</span><br><span class="line">        noRob = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return rob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="(202) Happy Number"></a>(202) Happy Number</h2><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p><strong>Example:</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">1^2 + 9^2 = 82</span><br><span class="line">8^2 + 2^2 = 68</span><br><span class="line">6^2 + 8^2 = 100</span><br><span class="line">1^2 + 0^2 + 0^2 = 1</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>我把数字1-20都统统算了一遍，去找出这题的规律<br>结果就是硬算，按照题目给的方法，唯一要找的规律就是怎么去判断是endless<br>答案就是n = 4</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; n != <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n)    </span><br><span class="line">        &#123;</span><br><span class="line">            tmp += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = tmp;</span><br><span class="line">        tmp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) return <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="(203) Remove Linked List Elements"></a>(203) Remove Linked List Elements</h2><p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题并不难，只是有个特殊情况需要考虑到<br>就是比如链表为[1]，而val = 1这个情况<br>在这个状况下，返回的是NULL</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> ListNode* <span class="title">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *newNode = (struct ListNode *)<span class="built_in">malloc</span>(sizeof(struct ListNode));</span><br><span class="line">    <span class="keyword">struct</span> ListNode *prev, *curr;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;val = <span class="number">0</span>;</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    prev = newNode;</span><br><span class="line">    curr = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (curr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;val == val)</span><br><span class="line">            prev-&gt;next = curr-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev = curr;</span><br><span class="line">        </span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return newNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="204-Count-Primes"><a href="#204-Count-Primes" class="headerlink" title="(204) Count Primes"></a>(204) Count Primes</h2><p>Count the number of prime numbers less than a non-negative number, <strong><em>n\</em></strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题解不难做，难点在于怎么优化<br>这里我主要也只是把hint的内容翻译一下，优化得真的棒<br>1）要判断 n 是不是素数，最普通的做法就是，从 2…n - 1 都除一遍，只要其中有一个能除尽，就不是素数<br>这样的话，时间复杂度是O(n)，有 n 个数要去判断，那么时间复杂度就是O(n^2^)<br>2）我们知道，当除数 &gt; (n / 2)是肯定除不尽的，比如：n = 10，那么 n / 6 肯定除不尽<br>那么除数就可以优化成 2…n / 2<br>3）以12为例子：<br>2 x 6 = 12，3 x 4 = 12，4 x 3 = 12，6 x 2 = 12<br>我们可以看到，4 x 3 和 6 x 2 是没有没有必要的，因此我们只要考虑 n 的开方就可以了<br>因为如果 n 能被 p 整除，那么就是说 n = p x q<br>而当 p 小于等于 q 的时候，我们有 p 小于根号 n<br>于是，我们将时间复杂度优化至O(n^1.5^)<br>4） <img src="https://leetcode.com/static/images/solutions/Sieve_of_Eratosthenes_animation.gif" alt="img"><br>如图所示，使用标记法，把不是素数的标记出来，可以有效减少我们判断的时间<br>5）标记法的原则是从2开始，所有2的倍数都标记，然后到3<br>那么到4么？并不，因为4已经被标记了，于是跳过，到5<br>6）那么从5 x 2，5 x 3开始吗？并不，因为5 x 2已经被2标记过了<br>所以可以优化成从5 x 5开始，也就是 p^2^，然后就是 p^2^ + p，p^2^ + 2p……<br>7）什么时候结束这个循环呢？当然就是当 p &lt; n的时候（没有等于是因为题目要求小于n）<br>这样子，整个思路都理清了，程序就出来了</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> *isNotPrime = (bool *)<span class="built_in">calloc</span>(n, sizeof(bool));</span><br><span class="line">    <span class="keyword">int</span> i, j, count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>; i*i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNotPrime[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=i*i; j&lt;n; j += i)</span><br><span class="line">            isNotPrime[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>; i&lt;n; i++)</span><br><span class="line">        count += (isNotPrime[i]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="(205) Isomorphic Strings"></a>(205) Isomorphic Strings</h2><p>Given two strings <strong><em>s\</em></strong> and <strong><em>t\</em></strong>, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in <strong><em>s\</em></strong> can be replaced to get <strong><em>t\</em></strong>.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>You may assume both <strong><em>s\</em></strong> and <strong><em>t\</em></strong> have the same length.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>简单的映射题<br>需要考虑的特殊情况，题目也已经说明了<br>就是把相同的字符映射到不同的地方</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="keyword">char</span> * s, <span class="keyword">char</span> * t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(s) != <span class="built_in">strlen</span>(t)) return <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> maps[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> mapt[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!maps[*s] &amp;&amp; !mapt[*t])</span><br><span class="line">        &#123;</span><br><span class="line">            maps[*s] = *t;</span><br><span class="line">            mapt[*t] = *s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (maps[*s] != *t || mapt[*t] != *s)</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        s++;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="(206) Reverse Linked List"></a>(206) Reverse Linked List</h2><p>Reverse a singly linked list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>我这里把迭代和递归的方法都写了，分别说一下<br>迭代的思路就是，设置三个变量，分别为：「之前」「现在」「以后」<br>很明显，这里是分别需要三个node的，于是要先判断是否为NULL的情况，否则NULL的next就出错了<br>然后判断「现在」是否存在，存在了，那么「现在」就指向「之前」<br>「之前」变为「现在」，「现在」变为「以后」，以后变为「以后」的以后，如此循环<br>需要判断的就是NULL的情况，宜家一开始的head，最终是肯定指向NULL的<br>递归有一个点是需要注意的，就是返回的，是head<br>也就是说，不能把整个链表倒过来后，返回的却是链尾，那就不对了<br>于是，首先直接递归到NULL，当head等于NULL，那么就返回NULL<br>设置两个变量，分别为：「新链头」「临时」<br>首先要考虑的点是，怎么样算是新链头？很明显，head-&gt;next = NULL的话，这个head就是新链头<br>接下来考虑怎么链接了<br>其实也很好想，当head指向新链表最后的值时，那么就是改链接的时候了<br>比如，新链头为5，那么整个链表其实是5-&gt;NULL<br>然后递归到head为4的时候，4的next为5，于是修改链接，5的next为4，4的next为NULL<br>在这里，4的next为NULL，但是3的next依然为4，如此反复，新链表就完成了</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"></span><br><span class="line">// iteratively</span><br><span class="line">struct ListNode* reverseList(struct ListNode* head)&#123;</span><br><span class="line">    struct ListNode *prev, *curr, *next;</span><br><span class="line">    </span><br><span class="line">    prev = head;</span><br><span class="line">    curr = (prev) ? prev-&gt;next : NULL;</span><br><span class="line">    next = (curr) ? curr-&gt;next : NULL;</span><br><span class="line">    </span><br><span class="line">    while (curr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (prev == head) prev-&gt;next = NULL;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">        next = next ? next-&gt;next : NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// recursively</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> ListNode* <span class="title">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) return <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> ListNode *newHead, *tmp;</span><br><span class="line">    newHead = reverseList(head-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (!newHead)</span><br><span class="line">    &#123;</span><br><span class="line">        newHead = head;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = newHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next != tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="(217) Contains Duplicate"></a>(217) Contains Duplicate</h2><p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>看到这题的第一反应，很明显就是用暴力穷举来解<br>然后不出所料，果然不行（超时）<br>然后想到的是排序后解，这样只要最多花O(n)的时间（不算排序时间）就可以得出答案<br>首先我是自己写的排序代码，用的是选择排序，结果还是超时<br>然后我查资料，才发现原来C有自带排序算法，就是qsort<br>用qsort就解决了问题<br>后来想了一下，应该也有第三种方法，就是哈希表法，不过由于比排序法解要麻烦太多<br>就没有写了</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmpfunc</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span></span>&#123;</span><br><span class="line">    return (*(int *)a - *(int *)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">1</span>) return <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(int), cmpfunc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i+<span class="number">1</span>]) return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="219-Contains-Duplicate-II"><a href="#219-Contains-Duplicate-II" class="headerlink" title="(219) Contains Duplicate II"></a>(219) Contains Duplicate II</h2><p>Given an array of integers and an integer <em>k</em>, find out whether there are two distinct indices <em>i</em> and <em>j</em> in the array such that <strong>nums[i] = nums[j]</strong> and the <strong>absolute</strong> difference between <em>i</em> and <em>j</em> is at most <em>k</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1], k = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,0,1,1], k = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题跟上一题很相像，主要问题也是时间复杂度<br>老规矩，暴力穷举试了一下，果然超时，不行<br>然后换个角度，你限制了一个k，也就是说，每次比较长度为k的数组里，是否有重复<br>那么运用上一题的方法，在numsSize里，每k个数为一个数组，然后排序寻找<br>不行，还是超时，貌似就只能用哈希表来做了<br>但这里其实可以把排序法和哈希法结合来做<br>方法很简单，建立一个哈希表，来表示各个元素之间的间隔<br>然后用冒泡法排序，不用等排序完，而是每次排序后比较<br>若是相等且不超过间隔k，就返回true，否则就是false<br>这个方法其实我也没想出来，是看了最佳答案后才知道的，妙啊</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> abs(a,b) ((a) &gt; (b) ? (a) - (b) : (b) - (a))</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* order = <span class="built_in">malloc</span>(sizeof(int)*numsSize);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        order[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] ^= nums[i+<span class="number">1</span>];</span><br><span class="line">                nums[i+<span class="number">1</span>] ^= nums[i];</span><br><span class="line">                nums[i] ^= nums[i+<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                order[i] ^= order[i+<span class="number">1</span>];</span><br><span class="line">                order[i+<span class="number">1</span>] ^= order[i];</span><br><span class="line">                order[i] ^= order[i+<span class="number">1</span>];</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>] &amp;&amp; abs(order[i], order[i+<span class="number">1</span>]) &lt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(order);</span><br><span class="line">                return <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(order);</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="(225) Implement Stack using Queues"></a>(225) Implement Stack using Queues</h2><p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>empty() – Return whether the stack is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyStack stack = new MyStack();</span><br><span class="line"></span><br><span class="line">stack.push(1);</span><br><span class="line">stack.push(2);  </span><br><span class="line">stack.top();   // returns 2</span><br><span class="line">stack.pop();   // returns 2</span><br><span class="line">stack.empty(); // returns false</span><br></pre></td></tr></table></figure>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <em>only</em> standard operations of a queue – which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题比之前stack要简单，然后我这里也稍微优化了一下<br>之前stack题，我是直接写死最大值是10000，因为测试用例里不超过这个最大值<br>但这里我用了动态分配，默认最大值是1000，要是超过了，就加1000<br>这样会比之前stack写死要好</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125; MyStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyStack* <span class="title">myStackCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyStack* <span class="built_in">queue</span> = (MyStack*)<span class="built_in">malloc</span>(sizeof(MyStack));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max = <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">array</span> = (int *)<span class="built_in">calloc</span>(queue-&gt;max, sizeof(int));</span><br><span class="line">    </span><br><span class="line">    return <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x onto stack. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStackPush</span><span class="params">(MyStack* obj, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    obj-&gt;<span class="built_in">array</span>[obj-&gt;size] = x;</span><br><span class="line">    obj-&gt;size++;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;size &gt;= obj-&gt;max)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;max += <span class="number">1000</span>;</span><br><span class="line">        obj-&gt;<span class="built_in">array</span> = (int *)<span class="built_in">realloc</span>(obj-&gt;max, sizeof(int));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStackPop</span><span class="params">(MyStack* obj)</span> </span>&#123;</span><br><span class="line">    obj-&gt;size--;</span><br><span class="line">    return (obj-&gt;array[obj-&gt;size]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the top element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStackTop</span><span class="params">(MyStack* obj)</span> </span>&#123;</span><br><span class="line">    return (obj-&gt;array[obj-&gt;size - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myStackEmpty</span><span class="params">(MyStack* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;size == <span class="number">0</span>) return <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStackFree</span><span class="params">(MyStack* obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your MyStack struct will be instantiated and called as such:</span><br><span class="line"> * MyStack* obj = myStackCreate();</span><br><span class="line"> * myStackPush(obj, x);</span><br><span class="line"> </span><br><span class="line"> * int param_2 = myStackPop(obj);</span><br><span class="line"> </span><br><span class="line"> * int param_3 = myStackTop(obj);</span><br><span class="line"> </span><br><span class="line"> * bool param_4 = myStackEmpty(obj);</span><br><span class="line"> </span><br><span class="line"> * myStackFree(obj);</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="(226) Invert Binary Tree"></a>(226) Invert Binary Tree</h2><p>Invert a binary tree.</p>
<p><strong>Example:</strong></p>
<p>Input:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<p><strong>Trivia:</strong><br>This problem was inspired by <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="external">this original tweet</a> by <a href="https://twitter.com/mxcl" target="_blank" rel="external">Max Howell</a>:</p>
<blockquote>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f<em>*</em> off.</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>很简单的一道题，直接用递归就可以了</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> TreeNode* <span class="title">invertTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) return <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;left = right;</span><br><span class="line">    root-&gt;right = left;</span><br><span class="line">    </span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="231-Power-of-Two"><a href="#231-Power-of-Two" class="headerlink" title="(231) Power of Two"></a>(231) Power of Two</h2><p>Given an integer, write a function to determine if it is a power of two.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: true </span><br><span class="line">Explanation: 20 = 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 24 = 16</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 218</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题我有点想多了，想着不用除法只用乘法（或移位）<br>但这样的话，需要声明3个变量，会额外占用内存空间<br>而且最多循环32次的除法，其实跟乘法不会有什么区别<br>而且用乘法需要考虑 int 越界的问题，更加得不偿失，因此这里用除法解最方便快捷</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) return <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) return <span class="literal">false</span>;</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="(232) Implement Queue using Stacks"></a>(232) Implement Queue using Stacks</h2><p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) – Push element x to the back of queue.</li>
<li>pop() – Removes the element from in front of queue.</li>
<li>peek() – Get the front element.</li>
<li>empty() – Return whether the queue is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // returns 1</span><br><span class="line">queue.pop();   // returns 1</span><br><span class="line">queue.empty(); // returns false</span><br></pre></td></tr></table></figure>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <em>only</em> standard operations of a stack – which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>
<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>
</ul>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>因为要求用stack的方法去做，也就是说，这题的考点是如何转变思路<br>其实很简单，结构体里多加一个记录栈底位置的变量即可<br>每次出栈，都是从栈底开始；入栈依然是放入栈顶<br>那么当栈顶 = 栈的最大值时，有两种情况<br>1）真的满了，栈底为0，那么就扩大栈的空间<br>2）不是真的满，栈底不为0，那么就往前挪</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INCREACE_SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> back;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125; MyQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyQueue* <span class="title">myQueueCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyQueue *<span class="built_in">queue</span> = (MyQueue *)<span class="built_in">malloc</span>(sizeof(MyQueue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;back = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = INCREACE_SIZE;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">array</span> = (int *)<span class="built_in">malloc</span>(queue-&gt;size * sizeof(int));</span><br><span class="line">    </span><br><span class="line">    return <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueuePush</span><span class="params">(MyQueue* obj, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    obj-&gt;<span class="built_in">array</span>[obj-&gt;back] = x;</span><br><span class="line">    obj-&gt;back++;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;back == obj-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;front == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            obj-&gt;size += INCREACE_SIZE;</span><br><span class="line">            obj-&gt;<span class="built_in">array</span> = (int *)<span class="built_in">realloc</span>(obj-&gt;array, obj-&gt;size * sizeof(int));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = obj-&gt;back - obj-&gt;front;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++, obj-&gt;front++)</span><br><span class="line">            &#123;</span><br><span class="line">                obj-&gt;<span class="built_in">array</span>[i] = obj-&gt;<span class="built_in">array</span>[obj-&gt;front];</span><br><span class="line">            &#125;</span><br><span class="line">            obj-&gt;front = <span class="number">0</span>;</span><br><span class="line">            obj-&gt;back = k - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePop</span><span class="params">(MyQueue* obj)</span> </span>&#123;</span><br><span class="line">    return obj-&gt;<span class="built_in">array</span>[obj-&gt;front++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePeek</span><span class="params">(MyQueue* obj)</span> </span>&#123;</span><br><span class="line">    return obj-&gt;<span class="built_in">array</span>[obj-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myQueueEmpty</span><span class="params">(MyQueue* obj)</span> </span>&#123;</span><br><span class="line">    return (obj-&gt;front == obj-&gt;back);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueueFree</span><span class="params">(MyQueue* obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your MyQueue struct will be instantiated and called as such:</span><br><span class="line"> * MyQueue* obj = myQueueCreate();</span><br><span class="line"> * myQueuePush(obj, x);</span><br><span class="line"> </span><br><span class="line"> * int param_2 = myQueuePop(obj);</span><br><span class="line"> </span><br><span class="line"> * int param_3 = myQueuePeek(obj);</span><br><span class="line"> </span><br><span class="line"> * bool param_4 = myQueueEmpty(obj);</span><br><span class="line"> </span><br><span class="line"> * myQueueFree(obj);</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="(234) Palindrome Linked List"></a>(234) Palindrome Linked List</h2><p>Given a singly linked list, determine if it is a palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>开始的时候我把这题想复杂了，想着能不能一个循环解决问题<br>但发现有太多的特殊情况需要判断，很难一个循环做出来<br>那么要是没有这个无谓的坚持的话，就很简单了</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) return <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> ListNode *tmp = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>[i++] = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] != <span class="built_in">array</span>[len-i<span class="number">-1</span>]) return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="(235) Lowest Common Ancestor of a Binary Search Tree"></a>(235) Lowest Common Ancestor of a Binary Search Tree</h2><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="external">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p>Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>All of the nodes’ values will be unique.</li>
<li>p and q are different and both values will exist in the BST.</li>
</ul>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>例题给的例子就不说了，我补充一些其他的例子<br>还是那个二叉树，但 p = 3， q = 9，那么 output 就应该为6<br>当 p = 3， q = 2的时候，output 就应该为2<br>我用递归写了一个正常普通的程序，参考代码1<br>然后发现一个更简洁方便的例子，参考代码2</p>
</blockquote>
<p><strong>代码1：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode *lca = <span class="literal">NULL</span>, *left, *right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        return lca;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root == p || root == q)</span><br><span class="line">        lca = root;</span><br><span class="line"></span><br><span class="line">    left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">        lca = root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left)</span><br><span class="line">        lca = (lca) ? lca : left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (right)</span><br><span class="line">        lca = (lca) ? lca : right;</span><br><span class="line">    </span><br><span class="line">    return lca;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码2：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="(237) Delete Node in a Linked List"></a>(237) Delete Node in a Linked List</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list – head = [4,5,1,9], which looks like following:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt="img"></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 1</span><br><span class="line">Output: [4,5,9]</span><br><span class="line">Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>The linked list will have at least two elements.</li>
<li>All of the nodes’ values will be unique.</li>
<li>The given node will not be the tail and it will always be a valid node of the linked list.</li>
<li>Do not return anything from your function.</li>
</ul>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这里的参数只给了node，没有给head<br>因此在调用这个函数的时候，应该会有<code>head-&gt;next = node</code>这样的语句<br>那么由于备注里已经声明了至少有2个元素、node肯定在链表里，已经node不会是tail<br>程序就完全不需要考虑特殊情况（已经全部被排除了）<br>这里不能单纯用node = node-&gt;next来做<br>因为这样的话，调用函数的时候node并不会变成node-&gt;next（因为不会返回）<br>因此要直接把node变得node-&gt;next</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">struct</span> ListNode* node)</span> </span>&#123;</span><br><span class="line">    node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">    node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="(242) Valid Anagram"></a>(242) Valid Anagram</h2><p>Given two strings <em>s</em> and <em>t</em> , write a function to determine if <em>t</em> is an anagram of <em>s</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p>
<p><strong>Follow up:</strong><br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>两个思路，一个是排序，另一个是哈希表<br>比较了一下，哈希表比较快和好写，于是就用哈希表来做</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="keyword">char</span> * s, <span class="keyword">char</span> * t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; *s; s++)</span><br><span class="line">        <span class="built_in">array</span>[*s]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; *t; t++)</span><br><span class="line">        <span class="built_in">array</span>[*t]--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">128</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] != <span class="number">0</span>) return <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="(257) Binary Tree Paths"></a>(257) Binary Tree Paths</h2><p>Given a binary tree, return all root-to-leaf paths.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line"></span><br><span class="line">Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>很有难度的一道题<br>首先，我们是用 C 做的，返回的是字符串空间需要自己 malloc<br>那么，我们就需要确定返回的 size，也就是 returnSize<br>这个 returnSize 怎么确定呢？很简单，就是 leaf 的个数<br>于是在代码里，我写了一个函数去获取二叉树 leaf 的个数<br>同时每个字符串长度也是要分配的，因此还需要些一个函数去获取二叉树 node 的个数<br>由于二叉树的值是 int，也就是说，单个 val 的长度，最大为10<br>因此总共该分配的空间为：node <em> 10 + (node - 1) </em> 2 + 1<br>node <em> 10是因为最大为10，这个已经提及过，(node - 1) </em> 2是因为<br>每个节点后要加上 “-&gt;”，而最后一个不需要加，因此是(node -1) * 2<br>至于为什么最后还要加1，是因为字符串，最后一位需要有 ‘\0’，因此还要+1<br>接下来就是如何遍历了，这里我使用的是迭代法，其实递归也是可以的，就不赘述了<br>由于 C 没有 vector 和 stack，我只能用一个数组来暂代<br>采用前序的遍历法，把遍历到的都存进数组中，代码中，k 就是栈顶的位置<br>而数组的长度，就是节点的个数，也就是上边运算前的 node 的值<br>这里需要注意的是，怎么确定一个节点我有没有遍历过呢？<br>很简单，由于我这个不是真正的栈，于是，出栈的操作，我也只是 k–<br>因此实际上，节点还是在我的数组中<br>所以，我只要将节点跟数组[k+1]比较一下，是否相等即可<br>这里要另外注意的是，由于每次遍历都是从左节点开始，因此进入左节点要比较两次，左节点和右节点都要比较<br>可若是只存在左节点，不存在右节点，且数组[k+1]并没有写入过，那么会形成死循环<br>因此在比较右节点的时候，需要额外判断右节点是否存在，避免死循环<br>而进入右节点则不需要这么麻烦，只要单纯比较右节点即可<br>以上还不是全部的坑，还有坑<br>这里二叉树的值是 int，不是只有个位数，会有十位甚至百位以上，甚至是带符号的<br>因此需要写一个函数 intToChar 来转换<br>你以为就结束了吗？no，no，no<br>还要考虑空的二叉树，和只有 root 的二叉树这些特殊情况<br>因此返回上一节点的操作，需要对 k 进行判断<br>总而言之，这是一道非常有难度，而且也很有趣的一道题<br>第一次做的时候，我偷懒，没有去获取 node 的个数，直接用一个常量（1000）来定义数组和字符串长度<br>LeetCode的测试用例没有超过这个范围，因此我AC了，但这是一个漏洞<br>因此我修改了后，虽然时间复杂度多了一些（多运行了一次O(n)）<br>但空间复杂度明显降了很多（虽然第一次的空间复杂度依然是100%）</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLeaf</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) return <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    </span><br><span class="line">    left = getLeaf(root-&gt;left);</span><br><span class="line">    right = getLeaf(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) left++;</span><br><span class="line">    </span><br><span class="line">    return (left + right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNode</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) return <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    </span><br><span class="line">    left = getNode(root-&gt;left);</span><br><span class="line">    right = getNode(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">1</span> + left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intToChar</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, tmp, a = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">32</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i = -i;</span><br><span class="line">        flag++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = i % <span class="number">10</span>;</span><br><span class="line">        arr[a++] = tmp + <span class="string">'0'</span>;</span><br><span class="line">        i /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) arr[a++] = <span class="string">'-'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (--a; a&gt;=<span class="number">0</span>; a--, j++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[j] = arr[a];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> ** <span class="title">binaryTreePaths</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, l = <span class="number">0</span>, node = getNode(root);</span><br><span class="line">    *returnSize = getLeaf(root);</span><br><span class="line">    <span class="keyword">char</span> **path = (char **)<span class="built_in">calloc</span>(*returnSize, sizeof(char *));</span><br><span class="line">    <span class="keyword">struct</span> TreeNode **tmp = (struct TreeNode **)<span class="built_in">calloc</span>(node, sizeof(struct TreeNode *));</span><br><span class="line">    node = (node * <span class="number">10</span>) + (node - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; *returnSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; tmp[k+<span class="number">1</span>] != root-&gt;left &amp;&amp; tmp[k+<span class="number">1</span>] != (root-&gt;right ? root-&gt;right : <span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k++] = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right &amp;&amp; tmp[k+<span class="number">1</span>] != root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k++] = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k] = root;</span><br><span class="line">            path[i] = (char *)<span class="built_in">calloc</span>(node, sizeof(char));</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">0</span>, l=<span class="number">0</span>; l&lt;k+<span class="number">1</span>; l++)</span><br><span class="line">            &#123;</span><br><span class="line">                j += intToChar(*(path + i) + j, tmp[l]-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (l &lt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    path[i][j++] = <span class="string">'-'</span>;</span><br><span class="line">                    path[i][j++] = <span class="string">'&gt;'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>) root = tmp[--k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>) root = tmp[--k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="258-Add-Digits"><a href="#258-Add-Digits" class="headerlink" title="(258) Add Digits"></a>(258) Add Digits</h2><p>Given a non-negative integer <code>num</code>, repeatedly add all its digits until the result has only one digit.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 38</span><br><span class="line">Output: 2 </span><br><span class="line">Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. </span><br><span class="line">             Since 2 has only one digit, return it.</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong><br>Could you do it without any loop/recursion in O(1) runtime?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>好无聊的一道题，这个鬼规律谁TM能想出来啊<br>规律： <a href="https://en.wikipedia.org/wiki/Digital_root" target="_blank" rel="external">Wikipedia article</a></p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    return (<span class="number">1</span> + (num - <span class="number">1</span>) % <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="263-Ugly-Number"><a href="#263-Ugly-Number" class="headerlink" title="(263) Ugly Number"></a>(263) Ugly Number</h2><p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are <strong>positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 6 = 2 × 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 8 = 2 × 2 × 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Output: false </span><br><span class="line">Explanation: 14 is not ugly since it includes another prime factor 7.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1</code> is typically treated as an ugly number.</li>
<li>Input is within the 32-bit signed integer range: [−2^31^, 2^31^ − 1].</li>
</ol>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>没什么难度的一道题，有两个限制条件<br>小于1的都为false（负数和0），另外 input 的质因子（prime factor）只能是2、3、5<br>当 input 为1的时候，同样为true</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) return <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) num /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span>) num /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num % <span class="number">5</span> == <span class="number">0</span>) num /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span> return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="268-Missing-Number"><a href="#268-Missing-Number" class="headerlink" title="(268) Missing Number"></a>(268) Missing Number</h2><p>Given an array containing <em>n</em> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,0,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这个题目是，从0到n，中间缺一个，求缺少的那个<br>数组是乱序的，首先想到的肯定是排序，能AC，但时间复杂度有点高<br>还有就是哈希表做，同样也能AC，但时间复杂度还是偏高，但比排序要好<br>最好的方法是，因为这是一个等差数列，因此用等差数列前N项和公式，能得出确切和的值<br>然后把确切和的值，减去数组相加的值，就能得出缺少的值</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    </span><br><span class="line">    i = numsSize * (numsSize + <span class="number">1</span>) / <span class="number">2</span> - sum;</span><br><span class="line">    </span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="278-First-Bad-Version"><a href="#278-First-Bad-Version" class="headerlink" title="(278) First Bad Version"></a>(278) First Bad Version</h2><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given n = 5, and version = 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>很明显，这题是要用二分法去解<br>原则是，false往左，true往右<br>需要设两个变量，一个prev，一个curr<br>当prev + 1 == curr的时候，结束循环</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = n / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(curr))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev + <span class="number">1</span> == curr) <span class="keyword">break</span>;</span><br><span class="line">            curr -= (curr - prev) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr += (n - curr == <span class="number">1</span> ? n - curr : (n - curr) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="(283) Move Zeroes"></a>(283) Move Zeroes</h2><p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:</p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这里要求按照数组原来的顺序，所以不能进行排序（就算可以，也不会变快）<br>因此重点是如何找出0与非0的数，并且进行交换</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, totalZeros = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nums[i]) totalZeros++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (totalZeros)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i - totalZeros] = nums[i];</span><br><span class="line">                nums[i] = nums[i] ^ nums[i - totalZeros];</span><br><span class="line">                nums[i - totalZeros] = nums[i] ^ nums[i - totalZeros];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="290-Word-Pattern"><a href="#290-Word-Pattern" class="headerlink" title="(290) Word Pattern"></a>(290) Word Pattern</h2><p>Given a <code>pattern</code> and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>
<p>Here <strong>follow</strong> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <strong>non-empty</strong> word in <code>str</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Notes:</strong><br>You may assume <code>pattern</code> contains only lowercase letters, and <code>str</code> contains lowercase letters that may be separated by a single space.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>题目帮我们排除了一些特殊情况，如：字符串内容为小写字母和空格，str 不为空<br>开始总结思路，很明显，这题要用哈希表去做<br>一个表对应的不再是一个字符，而是一串字符串<br>因此首要难题就是如何判断是否有重复字符串<br>解决方法很简单，就是循环，没法取巧<br>每次映射新的字符串的时候，判断与之前的是否重复<br>其他的没什么，就是判断结束后，还需要判断 pattern 和 str 是否都已经遍历完<br>因为 pattern 和 str 的格式个数应该是要一致的</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="keyword">char</span> * pattern, <span class="keyword">char</span> * str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> **mapping = (char **)<span class="built_in">calloc</span>(<span class="number">26</span>, sizeof(char *));</span><br><span class="line">    <span class="keyword">char</span> *token = strtok(str, <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">int</span> strLen = <span class="number">0</span>, patternLen = <span class="built_in">strlen</span>(pattern), i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (token &amp;&amp; strLen &lt; patternLen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断映射是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!mapping[pattern[strLen] - <span class="string">'a'</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 映射</span></span><br><span class="line">            mapping[pattern[strLen] - <span class="string">'a'</span>] = token;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;strLen; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断是否有重复映射</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(mapping[pattern[i] - <span class="string">'a'</span>], token))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">free</span>(mapping);</span><br><span class="line">                    return <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 判断映射内容与样式是否一致</span></span><br><span class="line">            <span class="keyword">if</span> (strcmp(mapping[pattern[strLen] - <span class="string">'a'</span>], token))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(mapping);</span><br><span class="line">                return <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        token = strtok(NULL, <span class="string">" "</span>);</span><br><span class="line">        strLen++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断pattern和str格式个数是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (strLen &lt; patternLen || token)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(mapping);</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="292-Nim-Game"><a href="#292-Nim-Game" class="headerlink" title="(292) Nim Game"></a>(292) Nim Game</h2><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: false </span><br><span class="line">Explanation: If there are 4 stones in the heap, then you will never win the game;</span><br><span class="line">             No matter 1, 2, or 3 stones you remove, the last stone will always be </span><br><span class="line">             removed by your friend.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>好蠢的一道题，无聊</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    return (n % <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="(299) Bulls and Cows"></a>(299) Bulls and Cows</h2><p>You are playing the following <a href="https://en.wikipedia.org/wiki/Bulls_and_Cows" target="_blank" rel="external">Bulls and Cows</a> game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>Write a function to return a hint according to the secret number and friend’s guess, use <code>A</code> to indicate the bulls and <code>B</code> to indicate the cows. </p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: secret = &quot;1807&quot;, guess = &quot;7810&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;1A3B&quot;</span><br><span class="line"></span><br><span class="line">Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: secret = &quot;1123&quot;, guess = &quot;0111&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;1A1B&quot;</span><br><span class="line"></span><br><span class="line">Explanation: The 1st 1 in friend&apos;s guess is a bull, the 2nd or 3rd 1 is a cow.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>输入的数据是字符串，不是int，输出的数据同样是字符串<br>因此我们要先得到 bull 的个数和 guess 的个数<br>这里先暂时不分配内存，因为不知道 bull 和 guess的长度的话，是无法申请分配的<br>bull 很简单，就是判断 secret[i] 是否等于 guess[i]<br>cow 的麻烦一些，开始我是只用一个数组来记录，当 secret[i] 不等于 guess[i] 的时候就记录<br>如 mapping[secret[i] - ‘0’]++ 和 mapping[guess[i] - ‘0’]++，然后用 cow = mapping[i] / 2来判断个数<br>但这样是行不通的，因为若是”1234”和”0111”这种情况，就会判断错误<br>因此没法，只能老老实实申请两个数组，各自记录，然后取小的那边的值<br>ok，现在 bull 和 cow 的值都得到了，可以开始准备写入到返回的字符串里了<br>首先要得到 bull 和 cow 的长度，这里要注意，要是 bull 和 cow 都为0，长度依然是1，而不能是0<br>否则后边写入到字符串的时候，就不好弄了，因此这里要额外判断一下<br>剩下的就没什么了，写入，返回，ojbk</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getHint</span><span class="params">(<span class="keyword">char</span> * secret, <span class="keyword">char</span> * guess)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> mapS[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;, mapG[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(secret), bulls = <span class="number">0</span>, cows = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到bull的个数，以及为得到cow的个数做准备</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (secret[i] == guess[i]) bulls++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mapS[secret[i] - <span class="string">'0'</span>]++;</span><br><span class="line">            mapG[guess[i] - <span class="string">'0'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到cow的个数</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cows += (mapS[i] &lt; mapG[i] ? mapS[i] : mapG[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到bull和cow的长度</span></span><br><span class="line">    <span class="keyword">int</span> bullsLen = <span class="number">0</span>, cowsLen = <span class="number">0</span>, tmp;</span><br><span class="line">    tmp = bulls;</span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp /= <span class="number">10</span>;</span><br><span class="line">        bullsLen++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = cows;</span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp /= <span class="number">10</span>;</span><br><span class="line">        cowsLen++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若是bull和cow的长度为0，变为1</span></span><br><span class="line">    <span class="keyword">if</span> (!bullsLen) bullsLen++;</span><br><span class="line">    <span class="keyword">if</span> (!cowsLen) cowsLen++;</span><br><span class="line">    <span class="comment">// 申请内存空间</span></span><br><span class="line">    <span class="keyword">char</span> *res = (char *)<span class="built_in">calloc</span>(bullsLen + cowsLen + <span class="number">3</span>, sizeof(char));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入返回的字符串中</span></span><br><span class="line">    <span class="keyword">for</span> (i=bullsLen<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i] = (bulls % <span class="number">10</span>) + <span class="string">'0'</span>;</span><br><span class="line">        bulls /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res[bullsLen] = <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=bullsLen+cowsLen; i&gt;=bullsLen+<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i] = (cows % <span class="number">10</span>) + <span class="string">'0'</span>;</span><br><span class="line">        cows /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res[bullsLen + cowsLen + <span class="number">1</span>] = <span class="string">'B'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要free，因为map的是数组，自动会释放，而res是返回，不能释放</span></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="303-Range-Sum-Query-Immutable"><a href="#303-Range-Sum-Query-Immutable" class="headerlink" title="(303) Range Sum Query - Immutable"></a>(303) Range Sum Query - Immutable</h2><p>Given an integer array <em>nums</em>, find the sum of the elements between indices <em>i</em> and <em>j</em> (<em>i</em> ≤ <em>j</em>), inclusive.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>You may assume that the array does not change.</li>
<li>There are many calls to <em>sumRange</em> function.</li>
</ol>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>题目并不难，不过由于 sumRange 函数会调用多次，因此在 SumRange 里累加，速度会很慢<br>因此要转变思路，在 Create 函数里累加，每一个元素都是累加的结果<br>如范例，NumArray 里的数组就是 {-2, -2, 1, -4, -2, -3}<br>其元素的值就是累加的结果，可以写成{sum(0), sum(0,1), sum(0,2), sum(0,3), sum(0,4), sum(0,5)}<br>那么如何得到 sum(2,5)呢？我们知道，sum(2,5)就是从2加到5，2,3,4,5<br>而sum(0,5)就是从0加到5，0,1,2,3,4,5，这时候，只要sum(0,5) - sum(0,1)就可以得到2,3,4,5<br>因此规律就出来了</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">&#125; NumArray;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NumArray* <span class="title">numArrayCreate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    NumArray *obj = (NumArray *)<span class="built_in">malloc</span>(sizeof(NumArray));</span><br><span class="line">    obj-&gt;arr = (int *)<span class="built_in">malloc</span>(numsSize * sizeof(int));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i) obj-&gt;arr[i] = nums[i];</span><br><span class="line">        <span class="keyword">else</span> obj-&gt;arr[i] = obj-&gt;arr[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numArraySumRange</span><span class="params">(NumArray* obj, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!i) return obj-&gt;arr[j];</span><br><span class="line">    <span class="keyword">else</span> return (obj-&gt;arr[j] - obj-&gt;arr[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">numArrayFree</span><span class="params">(NumArray* obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your NumArray struct will be instantiated and called as such:</span><br><span class="line"> * NumArray* obj = numArrayCreate(nums, numsSize);</span><br><span class="line"> * int param_1 = numArraySumRange(obj, i, j);</span><br><span class="line"></span><br><span class="line"> * numArrayFree(obj);</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="326-Power-of-Three"><a href="#326-Power-of-Three" class="headerlink" title="(326) Power of Three"></a>(326) Power of Three</h2><p>Given an integer, write a function to determine if it is a power of three.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 27</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 45</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong><br>Could you do it without using any loop / recursion?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>好劣质的一道题，蠢得一批<br>不用 loop / recursion 的方法就是单纯的，手算出在 int 的取值范围内，3的 n 次方可以得到 n 的最大值<br>结果就是 n = 19，那么3^19^就是1162261467<br>只要这个数 % input 为0，那么就是 power of three<br>就很蠢</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    return (n &gt; <span class="number">0</span>) &amp;&amp; (<span class="number">1162261467</span> % n == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="342-Power-of-Four"><a href="#342-Power-of-Four" class="headerlink" title="(342) Power of Four"></a>(342) Power of Four</h2><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong> Could you solve it without loops/recursion?</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>这题跟上一题非常相像，但是无法用上一题的方法去做<br>因为3是质因子，因此上一题的方法是可行的<br>但由于4并不是质因子，因此上一题的方法在此并不适用<br>我是用普通方法解（也就是用循环）<br>看了最佳答案，是真的妙啊<br>他的做法是这样的，第一个判断条件依然是 n &gt; 0，这个不用说<br>第二个判断条件是 (n &amp; (n - 1)) == 0，这个其实是判断是否为2的倍数<br>那么很自然，4的倍数也会包括进去<br>那么需要引入第三个判断条件：(n &amp; 0xaaaaaaaa) == 0<br>a 的二进制为1010，而4的二进制为0100，因此这么判断的话，会筛选掉只剩下4的次方的数<br>真的妙啊</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    return (num &gt; <span class="number">0</span>) &amp;&amp; ((num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>) &amp;&amp; ((num &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag">#Leetcode</a>
          
            <a href="/tags/c/" rel="tag">#c</a>
          
            <a href="/tags/algorithm/" rel="tag">#algorithm</a>
          
        </div>
      

      
      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/22/8/" rel="next" title="git笔记">
                  <i class="fa fa-chevron-left"></i> git笔记
                </a>
              
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2019/10/03/9/"
           data-title="LeetCode算法笔记（简单）" data-url="http://orionur.github.io/2019/10/03/9/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Orion" />
          <p class="site-author-name" itemprop="name">Orion</p>
          <p class="site-description motion-element" itemprop="description">理由は後だ、早く乗れ！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/orionids" target="_blank">
                  
                    <i class="fa fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="/images/wechat.jpg" target="_blank">
                  
                    <i class="fa fa-wechat"></i>
                  
                  Wechat
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://wpa.qq.com/msgrd?v=3&uin=33350096&site=qq&menu=yes" target="_blank">
                  
                    <i class="fa fa-qq"></i>
                  
                  QQ
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">1.</span> <span class="nav-text">(1) Two Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Reverse-Integer"><span class="nav-number">2.</span> <span class="nav-text">(7) Reverse Integer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Palindrome-Number"><span class="nav-number">3.</span> <span class="nav-text">(9) Palindrome Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-Roman-to-Integer"><span class="nav-number">4.</span> <span class="nav-text">(13)  Roman to Integer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-Longest-Common-Prefix"><span class="nav-number">5.</span> <span class="nav-text">(14)  Longest Common Prefix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-Valid-Parentheses"><span class="nav-number">6.</span> <span class="nav-text">(20) Valid Parentheses</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-Merge-Two-Sorted-Lists"><span class="nav-number">7.</span> <span class="nav-text">(21) Merge Two Sorted Lists</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-Remove-Duplicates-from-Sorted-Array"><span class="nav-number">8.</span> <span class="nav-text">(26) Remove Duplicates from Sorted Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-Remove-Element"><span class="nav-number">9.</span> <span class="nav-text">(27) Remove Element</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-Implement-strStr"><span class="nav-number">10.</span> <span class="nav-text">(28) Implement strStr()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-Search-Insert-Position"><span class="nav-number">11.</span> <span class="nav-text">(35) Search Insert Position</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-Count-and-Say"><span class="nav-number">12.</span> <span class="nav-text">(38) Count and Say</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-Maximum-Subarray"><span class="nav-number">13.</span> <span class="nav-text">(53) Maximum Subarray</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-Length-of-Last-Word"><span class="nav-number">14.</span> <span class="nav-text">(58) Length of Last Word</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-Plus-One"><span class="nav-number">15.</span> <span class="nav-text">(66) Plus One</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67-Add-Binary"><span class="nav-number">16.</span> <span class="nav-text">(67) Add Binary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#69-Sqrt-x"><span class="nav-number">17.</span> <span class="nav-text">(69) Sqrt(x)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70-Climbing-Stairs"><span class="nav-number">18.</span> <span class="nav-text">(70) Climbing Stairs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83-Remove-Duplicates-from-Sorted-List"><span class="nav-number">19.</span> <span class="nav-text">(83) Remove Duplicates from Sorted List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#88-Merge-Sorted-Array"><span class="nav-number">20.</span> <span class="nav-text">(88) Merge Sorted Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100-Same-Tree"><span class="nav-number">21.</span> <span class="nav-text">(100) Same Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#101-Symmetric-Tree"><span class="nav-number">22.</span> <span class="nav-text">(101) Symmetric Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree"><span class="nav-number">23.</span> <span class="nav-text">(104) Maximum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#107-Binary-Tree-Level-Order-Traversal-II"><span class="nav-number">24.</span> <span class="nav-text">(107) Binary Tree Level Order Traversal II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#108-Convert-Sorted-Array-to-Binary-Search-Tree"><span class="nav-number">25.</span> <span class="nav-text">(108) Convert Sorted Array to Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#110-Balanced-Binary-Tree"><span class="nav-number">26.</span> <span class="nav-text">(110) Balanced Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#111-Minimum-Depth-of-Binary-Tree"><span class="nav-number">27.</span> <span class="nav-text">(111) Minimum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-Path-Sum"><span class="nav-number">28.</span> <span class="nav-text">(112) Path Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#118-Pascal’s-Triangle"><span class="nav-number">29.</span> <span class="nav-text">(118) Pascal’s Triangle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#119-Pascal’s-Triangle-II"><span class="nav-number">30.</span> <span class="nav-text">(119) Pascal’s Triangle II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">31.</span> <span class="nav-text">(121) Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="nav-number">32.</span> <span class="nav-text">(122) Best Time to Buy and Sell Stock II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#125-Valid-Palindrome"><span class="nav-number">33.</span> <span class="nav-text">(125) Valid Palindrome</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#136-Single-Number"><span class="nav-number">34.</span> <span class="nav-text">(136) Single Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141-Linked-List-Cycle"><span class="nav-number">35.</span> <span class="nav-text">(141) Linked List Cycle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#155-Min-Stack"><span class="nav-number">36.</span> <span class="nav-text">(155) Min Stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists"><span class="nav-number">37.</span> <span class="nav-text">(160) Intersection of Two Linked Lists</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#167-Two-Sum-II-Input-array-is-sorted"><span class="nav-number">38.</span> <span class="nav-text">(167) Two Sum II - Input array is sorted</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#168-Excel-Sheet-Column-Title"><span class="nav-number">39.</span> <span class="nav-text">(168) Excel Sheet Column Title</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#169-Majority-Element"><span class="nav-number">40.</span> <span class="nav-text">(169) Majority Element</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#171-Excel-Sheet-Column-Number"><span class="nav-number">41.</span> <span class="nav-text">(171) Excel Sheet Column Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#172-Factorial-Trailing-Zeroes"><span class="nav-number">42.</span> <span class="nav-text">(172) Factorial Trailing Zeroes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#189-Rotate-Array"><span class="nav-number">43.</span> <span class="nav-text">(189) Rotate Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#190-Reverse-Bits"><span class="nav-number">44.</span> <span class="nav-text">(190) Reverse Bits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#191-Number-of-1-Bits"><span class="nav-number">45.</span> <span class="nav-text">(191) Number of 1 Bits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#198-House-Robber"><span class="nav-number">46.</span> <span class="nav-text">(198) House Robber</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#202-Happy-Number"><span class="nav-number">47.</span> <span class="nav-text">(202) Happy Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#203-Remove-Linked-List-Elements"><span class="nav-number">48.</span> <span class="nav-text">(203) Remove Linked List Elements</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#204-Count-Primes"><span class="nav-number">49.</span> <span class="nav-text">(204) Count Primes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#205-Isomorphic-Strings"><span class="nav-number">50.</span> <span class="nav-text">(205) Isomorphic Strings</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#206-Reverse-Linked-List"><span class="nav-number">51.</span> <span class="nav-text">(206) Reverse Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#217-Contains-Duplicate"><span class="nav-number">52.</span> <span class="nav-text">(217) Contains Duplicate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#219-Contains-Duplicate-II"><span class="nav-number">53.</span> <span class="nav-text">(219) Contains Duplicate II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#225-Implement-Stack-using-Queues"><span class="nav-number">54.</span> <span class="nav-text">(225) Implement Stack using Queues</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#226-Invert-Binary-Tree"><span class="nav-number">55.</span> <span class="nav-text">(226) Invert Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#231-Power-of-Two"><span class="nav-number">56.</span> <span class="nav-text">(231) Power of Two</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#232-Implement-Queue-using-Stacks"><span class="nav-number">57.</span> <span class="nav-text">(232) Implement Queue using Stacks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#234-Palindrome-Linked-List"><span class="nav-number">58.</span> <span class="nav-text">(234) Palindrome Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="nav-number">59.</span> <span class="nav-text">(235) Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#237-Delete-Node-in-a-Linked-List"><span class="nav-number">60.</span> <span class="nav-text">(237) Delete Node in a Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#242-Valid-Anagram"><span class="nav-number">61.</span> <span class="nav-text">(242) Valid Anagram</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#257-Binary-Tree-Paths"><span class="nav-number">62.</span> <span class="nav-text">(257) Binary Tree Paths</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#258-Add-Digits"><span class="nav-number">63.</span> <span class="nav-text">(258) Add Digits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#263-Ugly-Number"><span class="nav-number">64.</span> <span class="nav-text">(263) Ugly Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#268-Missing-Number"><span class="nav-number">65.</span> <span class="nav-text">(268) Missing Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#278-First-Bad-Version"><span class="nav-number">66.</span> <span class="nav-text">(278) First Bad Version</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#283-Move-Zeroes"><span class="nav-number">67.</span> <span class="nav-text">(283) Move Zeroes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#290-Word-Pattern"><span class="nav-number">68.</span> <span class="nav-text">(290) Word Pattern</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#292-Nim-Game"><span class="nav-number">69.</span> <span class="nav-text">(292) Nim Game</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#299-Bulls-and-Cows"><span class="nav-number">70.</span> <span class="nav-text">(299) Bulls and Cows</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#303-Range-Sum-Query-Immutable"><span class="nav-number">71.</span> <span class="nav-text">(303) Range Sum Query - Immutable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#326-Power-of-Three"><span class="nav-number">72.</span> <span class="nav-text">(326) Power of Three</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#342-Power-of-Four"><span class="nav-number">73.</span> <span class="nav-text">(342) Power of Four</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Orion</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强♂力♂驱♂动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"orion"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
